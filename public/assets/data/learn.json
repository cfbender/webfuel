[
  {
    "urlTitle": "js-eval-serverless",
    "title": "Creating a JavaScript Evaluator as a Serverless Function",
    "author": "cfbender",
    "authorLink": "https://github.com/cfbender",
    "content": "> Serverless functions are quickly becoming the hottest tech on the block, and here I'm going to show you how to easily incorporate  them into your React application!  Together we will build out the function that runs WebFuel's challenge mode, how the code is compiled and tested! The key to this deployment is going to be the package `serverless`, which makes deploying lambda functions incredibly easy.\n\n------------------------\n\n### First Steps\n\n+ You'll need:\n\n    + a bash/zsh/fish or similar terminal emulator\n    + yarn or npm (commands here will be shown with yarn)\n    + Node.js\n\n+ The `serverless` docs go into much more detail than I can fit here, so go follow the steps [here](https://github.com/serverless/serverless/blob/HEAD/docs/providers/aws/guide/credentials.md) to set up your AWS account and credentials if you don't already have them!\n\n#### Structuring\n\nFirst lets create our directory and navigate into it, then create our file and folder structure with:\n\n```bash\nmkdir evalJS\ncd evalJS\nmkdir lib\ntouch ./handler.js ./lib/eval.js ./serverless.yml\n```\n\nNow that we have those set up, let's go ahead and intialize our project in yarn and install our necessary packages!\n\n```bash\nyarn init -yq\nyarn global add serverless\nyarn add vm2 chai\n```\n_Note: if you can't run `serverless --help` directly from the terminal after installing, make sure [yarn is in your PATH](https://yarnpkg.com/lang/en/docs/cli/global/). _\n\n> Breakdown: We are intializing our code with a `package.json` file, then globally installing `serverless` so we can run it directly from the command line. Finally, we are installing our packages `vm2` and `chai` to run and test the user code respectively.\n\nNext, lets edit our `package.json` file to add a couple of scripts. Add in the `scripts` part here, to make yours look a little like this:\n```json\n{\n  ...\n  \"scripts\": {\n    \"deploy\": \"serverless deploy -f evalJS\",\n    \"log\": \"serverless logs -f evalJS\"\n  },\n  ...\n}\n\n```\n\nThis will simpify our commands later on, so that deploying and accessing the logs are easy! Now lets get to writing code!\n\n### The Function\n\nFirst, we will set up our function in `lib/eval.js`, which will take in user code and tests and run them in a sandboxed node environment. Here is the code (we will talk about it below):\n\n```javascript\nconst { NodeVM } = require(\"vm2\");\n\nmodule.exports =  async function evalJS(\n  { code, tests },\n  timeout = 10000\n) {\n  const vm = new NodeVM({\n    console: \"redirect\",\n    sandbox: {},\n    require: {\n      context: \"sandbox\",\n      builtin: [\"*\"],\n      external: true,\n      import: [\"chai\"]\n    },\n    timeout\n  });\n\n  let logs = [];\n\n  vm.on(\"console.log\", (data) => {\n    logs.push(data);\n  });\n\n  let result = await vm.run(\n    `const {expect} = require('chai'); \n        ${code} \n      \n        try{\n            ${tests}\n            \n            module.exports = {passed: true}\n        } catch(error){\n            module.exports = error\n            }`,\n    \"eval.js\"\n  );\n\n  return { result, logs, tests, code };\n}\n\n```\n\nLet's talk about what each part of this function does. First we are setting up a VM (virtual machine) node environment and saving that into `vm`. We pass it some options that redirect the console so we can save logs, and then have it import the `chai` library to run assertions against code. \n\nWe then initialize our `logs` array to store user logged statements so we can return them to them. We then set up an event listener in the vm for any `console.log` expressions, and push the result of them to our `logs` array. Finally, we run the code by placing it into a string and run any tests against the code. If any errors are thrown, the vm will export them, otherwise it will export an object that looks like `{passed: true}`. The function then returns the result, logs, and the input tests and code.\n\nNow that that is done, we just need to have a handler that AWS can run that will then run this function with any arguments we give it!\n\n### The Handler\n\nAWS Lambda functions are set up with a handler a lot like a `GET` or `POST` route in a `express` application. They call a function with a parameter signature of `(event, context, callback)`, where the `event` will contain the request information, and the callback is a function that will send a given response. All we need to do is take in the request body and have AWS call our evalJS function, and return the response! Lets do that with the following code:\n\n```javascript\n'use strict';\nconst evalJS = require(\"./lib/eval\");\n\nmodule.exports.evalJS = async (event, context, callback) => {\n\n  let { code, tests } = JSON.parse(event.body);\n    let response;\n  try {\n    let result = await evalJS({ code, tests });\n    if (result.result instanceof Error) {\n      result.result = result.result.toString();\n    }\n    response = {\n      statusCode: 200,\n      headers: {\n        'Access-Control-Allow-Origin': '*', // Required for CORS support to work\n      },\n      body: JSON.stringify(result),\n    };\n  } catch (error) {\n    console.error(error);\n    response = {\n      statusCode: 500,\n      headers: {\n        'Access-Control-Allow-Origin': '*', // Required for CORS support to work\n      },\n      body: JSON.stringify(error),\n    };\n  }\n\n  callback(null, response);\n};\n\n```\n\nHere we are running our evaluation, and returning the response or error if one occurs, then sending back the response with `callback`. We have to convert the result to a string if it's an error using the builtin `toString()` method on the Error, so that the user can see what went wrong.\n\nNow that we have that set up, all we have to do is deploy!\n\n### The Deployment\n\nWe need to tell `serverless` how to set up our function on AWS, and we do that with the `serverless.yml` file we created earlier. Open up that file and put in the following info:\n\n```yaml\n# The `service` block is the name of the service\nservice: evalJS\n\n# The `provider` block defines where your service will be deployed\nprovider:\n  name: aws\n  runtime: nodejs12.x\n\n# The `functions` block defines what code to deploy\nfunctions:\n  evalJS:\n    handler: handler.evalJS\n    # The `events` block defines how to trigger the handler.helloWorld code\n    events:\n      - http:\n          path: evalJS\n          method: post\n          cors: true\n          \n```\n\nThis sets up the service on a Node.js instance of version 12, and says we want to deploy a function named evalJS, that will listen for http requests at the `/evalJS` endpoint on `POST`, and to run the function `handler.evalJS`.\n\nServerless should give you back an endpoint that looks something like `https://cxwuxv59w5.execute-api.us-east-1.amazonaws.com/dev/evalJS`. If it does, you're all done! You will use that URL for your `POST` endpoint with the body containing the code and tests as a string, and the code should be evaluated and sent back.\n\nEnjoy testing and the ultimate scalability and speed of serverless functions!\n\n\n\n\n\n\n\n\n\n\n"
  }
]
